#!/usr/bin/python

import click
import glob
import logging
import mistune
import os
import sys
import urlparse

LOG = logging.getLogger('linkcheck')


class ValidationError(Exception):
    def __str__(self):
        return self.__doc__.format(super(ValidationError, self).__str__())


class MissingReference(ValidationError):
    '''No reference link named "{}"'''


class BrokenLink(ValidationError):
    '''File not found for path "{}"'''


class Validator:
    def __init__(self, src, pathmap=None, fail_fast=False, docroot='.'):
        self.src = src
        self.fail_fast = fail_fast
        self.docroot = docroot
        self.pathmap = pathmap
        self.errors = []

    def add_error(self, err):
        self.errors.append(err)

        if self.fail_fast:
            raise(err)

    def file_exists(self, path):
        LOG.debug('file_exists: processing path %s', path)

        paths = []

        for k, v in self.pathmap.items():
            if path.startswith(k):
                candidates = glob.glob(v)
                paths.extend(newpath + path[len(k):]
                             for newpath in candidates)
                break
        else:
            if path.startswith('/'):
                path = '{}/{}'.format(self.docroot, path)
            else:
                path = os.path.join(os.path.dirname(self.src), path)

            paths.append(path)

        resolved = []
        for path in paths:
            resolved.append(path)
            base, ext = os.path.splitext(path)
            if ext == '.html':
                resolved.append('{}.md'.format(base))

        LOG.debug('file_exists: resolved to: %s', resolved)
        return any(os.path.exists(p) for p in resolved)


class LinkCheckerRenderer(mistune.Renderer):
    def __init__(self, validator=None, *args, **kwargs):
        self._validator = validator
        super(LinkCheckerRenderer, self).__init__(*args, **kwargs)

    def link(self, link, title, text):
        url = urlparse.urlparse(link)
        if not url.scheme:
            if not self._validator.file_exists(url.path):
                self._validator.add_error(BrokenLink(link))

        return super(LinkCheckerRenderer, self).link(link, title, text)


class LinkCheckerLexer(mistune.InlineLexer):
    def __init__(self, validator=None, *args, **kwargs):
        self._validator = validator
        super(LinkCheckerLexer, self).__init__(*args, **kwargs)

    def output_reflink(self, m):
        key = m.group(2).lower() if m.group(2) else m.group(1).lower()
        if key not in self._links:
            self._validator.add_error(MissingReference(key))

        return super(LinkCheckerLexer, self).output_reflink(m)

    def output_autolink(self, m):
        return super(LinkCheckerLexer, self).output_autolink(m)

    def setup(self, links, footnotes):
        self._links = links
        self._footnotes = footnotes
        return super(LinkCheckerLexer, self).setup(links, footnotes)


@click.command()
@click.option('-f', '--fail-fast', is_flag=True)
@click.option('-d', '--docroot', default='.')
@click.option('-m', '--map', 'pathmap', multiple=True)
@click.option('-v', '--verbosity', is_flag=True, multiple=True)
@click.argument('paths', nargs=-1)
def main(fail_fast, docroot, verbosity, pathmap, paths):
    all_errors = 0
    pathmap = dict(x.split('=') for x in pathmap)
    verbosity = len(verbosity)

    try:
        loglevel = ['WARNING', 'INFO', 'DEBUG'][verbosity]
    except IndexError:
        loglevel = 'DEBUG'

    logging.basicConfig(level=loglevel)

    for path in paths:
        validator = Validator(path,
                              pathmap=pathmap, 
                              fail_fast=fail_fast,
                              docroot=docroot)
        renderer = LinkCheckerRenderer(validator=validator)
        lexer = LinkCheckerLexer(validator, renderer)
        markdown = mistune.Markdown(renderer, inline=lexer)

        try:
            with open(path, 'r') as fd:
                markdown(fd.read())
        except ValidationError:
            pass

        if validator.errors:
            all_errors += len(validator.errors)
            print('{}:'.format(path))
            for err in validator.errors:
                print('  {}'.format(err))

    if all_errors:
        raise click.ClickException('Found {} validation errors'.format(all_errors))

if __name__ == '__main__':
    main()
